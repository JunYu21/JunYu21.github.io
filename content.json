{"meta":{"title":"JunYu","subtitle":"","description":"","author":"John Doe","url":"https://JunYu21.github.io","root":"/"},"pages":[{"title":"作者","date":"2024-01-21T02:44:24.000Z","updated":"2024-01-22T08:34:39.453Z","comments":false,"path":"about/index.html","permalink":"https://junyu21.github.io/about/index.html","excerpt":"","text":"xxxxxxxxxxxx"}],"posts":[{"title":"Hexo搭建博客","slug":"hexo","date":"2024-01-21T06:43:01.756Z","updated":"2024-01-21T06:42:40.481Z","comments":true,"path":"2024/01/21/hexo/","link":"","permalink":"https://junyu21.github.io/2024/01/21/hexo/","excerpt":"","text":"参考博客：hexo+gitee(码云)免费搭建个人静态博客（避开所有坑） - 知乎 (zhihu.com) 1.1 –hexo史上最全搭建教程https://blog.csdn.net/sinat_37781304&#x2F;article&#x2F;details&#x2F;82729029 1.2 –Markdown 基本语法Markdown 基本语法 | Markdown 官方教程 1.3 –hexo+gitee(码云)搭建个人博客https://blog.csdn.net/weixin_45 Hexo博客搭建步骤 安装 Hexo 初始化 Hexo 编写文章 生成静态文件 部署到服务器或托管平台 1. Hexo 介绍Hexo 是一个基于 Node.js 的静态博客框架，它可以帮助你快速搭建静态博客网站。Hexo 将 Markdown 文件转换为静态 HTML 页面，使得博客的搭建和管理变得简单、高效。 2. Hexo 的一些重要特点和组成部分 Markdown支持： Hexo 使用 Markdown 来书写博客文章，Markdown 是一种轻量级且易于书写的标记语言。 静态网站生成： Hexo 将 Markdown 文件解析并转换为静态 HTML 页面，这样可以提高网站的加载速度和安全性。 主题和样式： Hexo 支持各种主题和样式，可以根据个人喜好选择或自定义主题，使博客具有吸引力和个性化。 插件系统： Hexo 有丰富的插件系统，可以通过插件扩展其功能，比如优化、标签云、SEO等。 标签和分类： 可以对文章进行标签和分类，方便读者快速找到感兴趣的内容。 自动部署： 可以配置自动部署到各种主流的博客托管平台，如GitHub Pages、Netlify等。 快速： Hexo 提供快速的构建和部署功能，使得博客搭建的过程高效便捷。 3. Hexo相关命令hexo的安装 1npm install hexo-cli -g 初始化项目 1hexo init blogName 清空已经存在的hexo网站文件 1hexo clean 依据网页文件和新的css样式生成新的网站文件 1hexo generate(可简写g) 启动本地服务器，可以在localhost：4000查看网站修改效果 1hexo server(可简写为s) 创建一篇文章，根目录的source里面的md文件可以修改文章内容 1hexo new &quot;我的第一篇文章&quot; 安装上传到仓库的插件，才能进行发布文章的命令 1npm install hexo-deployer-git --save 发布文章 一键部署并推送到gitee仓库上 1hexo g --d 4. 主题fluid主题 leaf-domain 开始使用 | Hexo Fluid 用户手册 (fluid-dev.github.io) 配置指南 | Hexo Fluid 用户手册 (fluid-dev.com) 进阶用法 | Hexo Fluid 用户手册 (fluid-dev.com) butterfly主题 github下载地址 next主题等等 自己玩去吧","categories":[{"name":"搭建自己的博客","slug":"搭建自己的博客","permalink":"https://junyu21.github.io/categories/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://junyu21.github.io/tags/hexo/"},{"name":"git","slug":"git","permalink":"https://junyu21.github.io/tags/git/"},{"name":"nodejs","slug":"nodejs","permalink":"https://junyu21.github.io/tags/nodejs/"},{"name":"blog","slug":"blog","permalink":"https://junyu21.github.io/tags/blog/"}]},{"title":"文件推送到远程部署","slug":"html部署","date":"2024-01-21T06:39:55.078Z","updated":"2024-01-21T06:38:29.704Z","comments":true,"path":"2024/01/21/html部署/","link":"","permalink":"https://junyu21.github.io/2024/01/21/html%E9%83%A8%E7%BD%B2/","excerpt":"","text":"如何免费静态部署一个html网页使每个人都可以访问到-CSDN博客 效果展示: 叶域的博客 烟花烟花的源码都在仓库中可自行copy 配套视频教程:手把手教你免费部署Html静态界面_哔哩哔哩_bilibili 一，准备工作 下载git并配置环境变量 官网下载地址: Git - Downloads (git-scm.com) git的介绍 Git - Git 是什么？ (git-scm.com) 注册[Gitee](Gitee - 基于 Git 的代码托管和研发协作平台)账号并登录 Gitee的介绍与使用: Gitee入门教程: 轻松入门Gitee 二，使用Gitee提供的Gitee Pages 服务进行部署 将本地文件推送到远程仓库 打开Pages服务 备注: 实名认证可能要个几天hh","categories":[{"name":"项目部署","slug":"项目部署","permalink":"https://junyu21.github.io/categories/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/"}],"tags":[{"name":"git","slug":"git","permalink":"https://junyu21.github.io/tags/git/"},{"name":"gitee","slug":"gitee","permalink":"https://junyu21.github.io/tags/gitee/"},{"name":"html","slug":"html","permalink":"https://junyu21.github.io/tags/html/"}]},{"title":"Qt学习第一天：新建qt工程，编写helloWorld，按钮信号和槽","slug":"qt1","date":"2024-01-21T06:39:51.102Z","updated":"2024-01-21T06:39:08.308Z","comments":true,"path":"2024/01/21/qt1/","link":"","permalink":"https://junyu21.github.io/2024/01/21/qt1/","excerpt":"","text":"Qt学习第一天：新建qt工程，编写helloWorld，按钮信号和槽-CSDN博客 一，C++面向对象学习qt要有一些c++面向对象的基础C++的类与类之间存在上下级的关系，类可以继承另外一个类。被继承的类通常称作为是基类。而主动继承的类通常被称作是派生类。 二，创建qt项目 创建工程时选择的QWidget类。 该工程的目的就是为了创建一个窗口，对Qt的界面开发，就是基于此工程的，可以在窗口上添加组件或者自由设计均可。 然后一键next 三，目录详细介绍 1，C++程序的入口main.cpp1234567891011121314// widget.h是Qt生成窗口用的类，该类继承了QWidget类，也就意味着widget类包含了QWidget类的所有功能。#include &quot;widget.h&quot;// 大写的Q为开头的类，都是Qt提供给我们的类#include &lt;QApplication&gt;int main(int argc, char *argv[])&#123; // QApplication类作为Qt程序的入口实现。也作为程序的结束。 QApplication a(argc, argv); // 实例化一个窗口类的对象w Widget w; // w.show()的作用是使得窗口能够显示出来 w.show(); return a.exec();&#125; 2，Qt生成窗口的类的头文件widget.h1234567891011121314151617181920212223#ifndef WIDGET_H#define WIDGET_H// 添加基类的头文件#include &lt;QWidget&gt;QT_BEGIN_NAMESPACE// 声明命名空间Ui，Ui下声明了Widget类namespace Ui &#123; class Widget; &#125;QT_END_NAMESPACE// Widget公共继承QWidgetclass Widget : public QWidget&#123; // Qt提供给类的宏定义，里面包含了Qt的核心机制，必须要添加，否则极有可能造成程序编译错误。 Q_OBJECTpublic: // 构造函数：基类的指针，默认值为nullptr Widget(QWidget *parent = nullptr); // 析构函数，这里也是一个虚析构函数 ~Widget();private: // 命名空间下Widget类的指针 Ui::Widget *ui;&#125;;#endif // WIDGET_H 3，Qt生成窗口的类的实现文件widget.cpp1234567891011121314151617181920#include &quot;widget.h&quot;#include &quot;ui_widget.h&quot;// 以下写法为构造函数的初始化列表// 初始化列表在这里的作用是：// 1) 将参数parent透过基类的构造函数传参，并调用基类的构造函数// 2) 将ui指针实例化Ui::Widget对象Widget::Widget(QWidget *parent) : QWidget(parent) , ui(new Ui::Widget)&#123; // ui对象调用成员函数setupUi,其作用为，运行设计师界面的内容 ui-&gt;setupUi(this);&#125;Widget::~Widget()&#123; // 释放ui指针的堆空间 delete ui;&#125; 四，写个hello world并调节其样式1，通过代码实现在widget.h头文件中添加12#include &lt;QLabel&gt; // 声明组件所需要用到的类QLabel *label; // 声明组件所需要用到的指针 添加后 1234567891011121314151617181920#ifndef WIDGET_H#define WIDGET_H#include &lt;QWidget&gt;// 声明组件所需要用到的类#include &lt;QLabel&gt;QT_BEGIN_NAMESPACEnamespace Ui &#123; class Widget; &#125;QT_END_NAMESPACEclass Widget : public QWidget&#123; Q_OBJECTpublic: Widget(QWidget *parent = nullptr); ~Widget();private: Ui::Widget *ui; // 声明组件所需要用到的指针 QLabel *label;&#125;;#endif // WIDGET_H widget.cpp里1234567891011121314151617181920212223#include &quot;widget.h&quot;#include &quot;ui_widget.h&quot;Widget::Widget(QWidget *parent) : QWidget(parent) , ui(new Ui::Widget)&#123; ui-&gt;setupUi(this); // 调整窗口的大小 resize(400, 300); // 实例化标签对象，第一个参数&quot;Hello World&quot;代表label的文本信息。 // 第二个参数this，代表窗口，意思是将label标签贴在this窗口上 label = new QLabel(&quot;Hello World&quot;, this); // setGeometry代表设置组件的几何信息，包括：x坐标，y坐标，w宽度，h高度 label-&gt;setGeometry(0, 0, 400, 300); // setAlignment代表设置组件内字体的对齐方式，Qt::AlignCenter也代表将文字居中对齐 label-&gt;setAlignment(Qt::AlignCenter); // setStyleSheet代表设置组件的样式表，其中可以修改字体的大小。 label-&gt;setStyleSheet(&quot;font:50px&quot;);&#125;Widget::~Widget()&#123; delete ui;&#125; 运行结果 拉伸窗口会发现Hello World会原位不动 设计样式1 将label组件始终放在窗口的正中间在Qt生成的工程当中，如果没有添加组件，并且可以拉伸窗口大小的话，拉太小可能会隐藏窗口上的组件，拉太大又有些影响美观，所以我们想要，保持组件们一直持续显示在窗口的正中央。 1) 在widget.h头文件中添加12#include &lt;QHBoxLayout&gt; // 声明组件所需要用到的类QHBoxLayout *hboxlayout; // 声明组件所需要用到的指针 上同 2) widget.cpp里添加12345// QHBoxLayout的基类是QBoxLayout，他还有一个兄弟，为QVBoxLayout，自己是水平布局，兄弟是垂直布局。// 所有的布局往上的基类都是QLayouthboxlayout = new QHBoxLayout(this);// 在布局里添加组件hboxlayout-&gt;addWidget(label); 这样如何拉伸界面Hello World都会在窗户正中央 设计样式2 样式表在Qt中，修改组件或者窗口的字体、背景颜色等等，都可以通过设置样式表实现。一些比较炫酷的界面效果也可以用样式表实现。 在如下的代码实例中，不同的样式表语句，需要用分号隔开，不然会引起冲突。由于不会对函数内的字符串类型纠错，注意不得有拼写错误。 12345678// font可以设置字体的样式// background-color修改背景颜色// color修改文本信息的颜色// rgb表示颜色由红绿蓝三色组成，每个颜色的通道占据一个字节的数据(最大值为FF，255) label-&gt;setStyleSheet(&quot;font:50px;\\ background-color:rgb(45, 9, 34);\\ color:rgb(255, 255, 255);\\ &quot;); 在Qt中，也可以用QSS语句实现样式表的功能，QSS语句类似于HTML CSS语言，用{}整合想要的数据，在内部通过 “属性:数值” 的方式设置自己想要的效果 1234567QString sheet = &quot;QLabel\\ &#123;\\ font:50px;\\ background-color:rgb(22, 22, 11);\\ color:rgb(19, 133, 33);\\ &#125;;&quot;;label-&gt;setStyleSheet(sheet); 2，进入Qt设计师界面先双击Forms文件夹下widget.ui文件，进入Qt设计师界面。在左列中找到label，将label拖拽到窗口的正中间在右上角对象与类的列表中，找到窗口Widget，点击选中窗口。在右下角geometry可以修改窗口的尺寸，再同步以下label的位置。选择label，在右下角找到alignment，水平和垂直均选择为Center，代表居中对齐。选中label，找到font，透过调整点大小的值来修改字体的大小。 五，按钮1，创建按钮当我们在设计师界面中，将按钮放置在布局里时，按钮的高度并不会发生改变，同时变得很扁。这是因为它垂直的尺寸策略为fixed固定值，需要将其修改为与水平除了相一致的Minimum即可，或者统一修改为fixed，同时设置按钮尺寸的最小尺寸。 2，信号和槽信号和槽其实是一个函数 1QObject::connect() connect函数的作用是连接信号和槽。 QObject类是Qt里最上层的类。绝大多数的Qt类往上，都会继承该类，也可以算是Qt里的祖宗类该QObject可以用来表示窗口，也可以用来表示组件、控件的对象 12345678QMetaObject::Connection QObject::connect( const QObject *sender, // 信号的发送者 const char *signal, // 具体的信号 const QObject *receiver, // 信号的接收者 const char *method, // 槽函数 Qt::ConnectionType type = Qt::AutoConnection ) 具体的信号和槽函数是分别通过SIGNAL()和SLOT()实现的。这是两个宏定义函数，最终转换成了char* 字符串类型 1）点击按钮之后，将整个窗口显示全屏。第一个方案：利用信号和槽的编辑界面来完成相应功能 先来到设计师界面，首先保证界面内有一个按钮。在上方工具栏中点击第二个按钮，第二个按钮的意思就是edit signal&#x2F;slot，专门用来编辑信号和槽的界面。想要实现信号和槽，就要分析谁是信号的发送者？谁是信号的接收者？在该案例中，点击按钮之后，窗口才会做出反应，所以信号的发送者就是按钮，信号的接收者为窗口。点击按钮，长按，往外拖出一跟线，连接到窗口上。在配置连接的对话框中，点击下方从QWidget继承的信号和槽，左边信号选择按钮的clicked()信号，右边的槽函数选择窗口的showFullScreen()槽函数。 第二个方案：通过转到槽来实现相应功能来到设计师界面中，找按钮，右键点击，选择转到槽的操作。此时，需要选择连接的信号，选择clicked()。 跳转到代码页面中此时widget.h会自动生成以下代码： 1234// 所有槽函数的声明都应该放在slots下，至于是public slots还是private slots都可以。private slots: // 自动生成的槽函数，名称以on为开头，加上信号发送者的名字，再加上信号名称组成槽函数的名字。 void on_pushButton_clicked(); 此时widget.cpp也会自动生成以下代码： 123456void Widget::on_pushButton_clicked()&#123; // 写上槽函数的代码逻辑，即点击按钮之后会发生什么。 // 例如: close(); 关闭窗口 showFullScreen(); // 全屏显示&#125; 2) 反复点击按钮之后，可以使得label上的信息来回切换widget.h widget.cpp","categories":[{"name":"Qt学习","slug":"Qt学习","permalink":"https://junyu21.github.io/categories/Qt%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"qt","slug":"qt","permalink":"https://junyu21.github.io/tags/qt/"}]},{"title":"Hello World","slug":"hello-world","date":"2024-01-20T12:31:10.448Z","updated":"2024-01-20T12:30:00.348Z","comments":true,"path":"2024/01/20/hello-world/","link":"","permalink":"https://junyu21.github.io/2024/01/20/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"搭建自己的博客","slug":"搭建自己的博客","permalink":"https://junyu21.github.io/categories/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/"},{"name":"项目部署","slug":"项目部署","permalink":"https://junyu21.github.io/categories/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/"},{"name":"Qt学习","slug":"Qt学习","permalink":"https://junyu21.github.io/categories/Qt%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://junyu21.github.io/tags/hexo/"},{"name":"git","slug":"git","permalink":"https://junyu21.github.io/tags/git/"},{"name":"nodejs","slug":"nodejs","permalink":"https://junyu21.github.io/tags/nodejs/"},{"name":"blog","slug":"blog","permalink":"https://junyu21.github.io/tags/blog/"},{"name":"gitee","slug":"gitee","permalink":"https://junyu21.github.io/tags/gitee/"},{"name":"html","slug":"html","permalink":"https://junyu21.github.io/tags/html/"},{"name":"qt","slug":"qt","permalink":"https://junyu21.github.io/tags/qt/"}]}